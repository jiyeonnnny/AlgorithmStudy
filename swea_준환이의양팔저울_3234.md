```py
def idx_dfs(lst, depth):
    if depth==n:
        idx_sequence.append(lst[:])
        return
    for i in range(n):
        if visit_idx[i]==0:
            visit_idx[i]=1
            lst.append(i)
            idx_dfs(lst,depth+1)
            lst.pop()
            visit_idx[i]=0

def dfs(idx,depth):
    global ans
    if depth == n:
        if bit == [0]*n:
            return
        if bit == [1]*n:
            ans += factorial[n]
            return
        for idx_sq in idx_sequence:
            l = r = 0
            if bit[idx_sq[0]]==0:
                break
            for ii in idx_sq:
                if bit[ii]==0:
                    r+=arr[ii]
                else:
                    l+=arr[ii]
                if l<r:
                    break
            else:
                ans+=1
        return
    for i in range(2):
        bit[idx] = i
        dfs(idx+1, depth+1)


factorial = [0]*10
factorial[0] = factorial[1] = 1
for i in range(2,10):
    factorial[i] = factorial[i-1]*i

for t in range(int(input())):
    n = int(input())
    arr = list(map(int, input().split()))
    idx_sequence = []
    visit_idx = [0]*n
    idx_dfs([],0)
    ans = 0
    bit = [0]*n
    dfs(0,0)
    print(f'#{t+1} {ans}')
```
[틀림]
- 일단 idx_sequence list가 빈 list로 나왔음
- 주소가 복사되면서, lst.pop할때 idx_sequence도 함께 pop되었음
- 해결하기 위해 append할때 lst[:]한 것을 append해줌
- dfs함수에서, 일부 case만 출력되었음. 이유를 모르겠다 싶었는데 **디버깅** 해보니, r에 가장 먼저 더해줄 경우, break을 하는 바람에, 그 case의 순열을 바꾼 경우를 자동으로 count해주지 못하고 끝났음

<br>
<br>
<br>


```py
def idx_dfs(lst, depth):
    if depth==n:
        idx_sequence.append(lst[:])
        return
    for i in range(n):
        if visit_idx[i]==0:
            visit_idx[i]=1
            lst.append(i)
            idx_dfs(lst,depth+1)
            lst.pop()
            visit_idx[i]=0

def dfs(idx,depth):
    global ans
    if depth == n:
        if bit == [0]*n:
            return
        if bit == [1]*n:
            ans += factorial[n]
            return
        for idx_sq in idx_sequence:
            l = r = 0
            if bit[idx_sq[0]]==0:
                continue
            for ii in idx_sq:
                if bit[ii]==0:
                    r+=arr[ii]
                else:
                    l+=arr[ii]
                if l<r:
                    break
            else:
                ans+=1
        return
    for i in range(2):
        bit[idx] = i
        dfs(idx+1, depth+1)



factorial = [0]*10
factorial[0] = factorial[1] = 1
for i in range(2,10):
    factorial[i] = factorial[i-1]*i

for t in range(int(input())):
    n = int(input())
    arr = list(map(int, input().split()))
    idx_sequence = []
    visit_idx = [0]*n
    idx_dfs([],0)
    ans = 0
    bit = [0]*n
    dfs(0,0)
    print(f'#{t+1} {ans}')
```
[수정 완료]
- 값이 잘 나옴

<br>

[시간초과남]
-어떻게 해결할 수 있을까?
- 가지치기가 필요함, 순서상관없이 r의 총 합이 큰 경우,

<br>
<br>
<br>
