```py
import sys
input = sys.stdin.readline
from collections import deque

d = [[0,1],[0,-1],[1,0],[-1,0]]
def bfs():
    while players:
        num,x,y,depth = players.popleft()
        stack = [[num,x,y,0]]
        while stack:
            if stack[-1][3]==Sp[num-1]:
                break
            num,x,y,depth = stack.pop()
            for dx,dy in d:
                nx = x + dx
                ny = y + dy
                if 0<=nx<n and 0<=ny<m and arr[nx][ny]=='.':
                    arr[nx][ny]=num
                    cnt[num-1]+=1
                    stack.append([num,nx,ny,depth+1])
        # depth를 뺀 stack을 extend해줘야함
        # 근데 depth를 제외하고 stack자체를 구성할 순 없음
        # 그렇다고 for문 돌리기엔 시간 비효율적임
        # dfs할땐 depth를 고려하면서
        # players엔 depth없이 사용할 순 없을까
        # players에는 필요없는 depth이긴 한데, 이렇게 넣으면 메모리를 조금 더 쓰면서 시간은 효율적으로 쓸 수 있음
        players.extend(stack)

n,m,p = map(int, input().split())
Sp = list(map(int, input().split()))
arr = [list(input().strip()) for _ in range(n)]
players = []
cnt = [0]*(p)
for i in range(n):
    for j in range(m):
        if arr[i][j]!='.' and arr[i][j]!='#':
            players.append([int(arr[i][j]),i,j,0])
            arr[i][j] = int(arr[i][j])
            cnt[int(arr[i][j])-1]+=1
players.sort(key=lambda x:x[0])
players = deque(players)
bfs()
print(*cnt)
```
[틀렸습니다]
- 반례 찾기
- 우선순위큐를 사용하는 방법
