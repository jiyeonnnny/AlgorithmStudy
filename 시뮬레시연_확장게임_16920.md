[주의사항]
1. bfs + dfs로 하면 발생하는 반례

3 4 2
2 1
1...
1..2
....
답 9 3

2. bfs + bfs 어떻게 구현하나
   - dictionary로는 안될까
   - 출력 순서는?
     - 저장순 보장됨
     - for key in dic.keys()
     - for i in range(1,p+1)
   - 언제 while문을 멈출것인가?
     - 비어있는 deque 개수를 셈
    
[결론]
- 이게 되네
- heap 쓰는 방법 공부하기

```py
import sys
input = sys.stdin.readline
from collections import deque

d = [[0,1],[0,-1],[1,0],[-1,0]]
def bfs():
    while True:
        finish = 0
        for num in range(1,p+1):
            if len(players[num])==0:
                finish+=1
                continue
            player = players[num]
            players[num] = deque()
            while player:
                x,y,depth = player.popleft()
                for dx,dy in d:
                    nx,ny = x + dx,y + dy
                    if 0<=nx<n and 0<=ny<m and arr[nx][ny]=='.':
                        arr[nx][ny] = num
                        cnt_num[num]+=1
                        if depth+1 == Sp[num]:
                            players[num].append((nx,ny,0))
                        else:
                            player.append((nx,ny,depth+1))
        # print(players)
        if finish==p:
            return


n,m,p = map(int,input().split())
Sp = [0]+list(map(int, input().split()))
arr = [list(input().strip()) for _ in range(n)]
cnt_num = [0]*(p+1)
players = dict()
for i in range(1,p+1):
    players[i] = deque()

for i in range(n):
    for j in range(m):
        if arr[i][j].isdigit():
            players[int(arr[i][j])].append((i,j,0))
            cnt_num[int(arr[i][j])]+=1
bfs()
print(*cnt_num[1:])
```
